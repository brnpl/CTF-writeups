## Overview
This writeup details the reverse engineering of an Android application that requires instantiating a class and calling an instance method using Frida. The goal is to reverse engineer the flag retrieval mechanism by creating an instance of the `Check` class and calling its `get_flag()` method with the correct parameter to decode the hidden flag.

## Initial analysis
The `AndroidManifest.xml` shows a minimal application structure with the main activity `com.ad2001.frida0x4.MainActivity` as the entry point. 

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android" android:versionCode="1" android:versionName="1.0" android:compileSdkVersion="33" android:compileSdkVersionCodename="13" package="com.ad2001.frida0x4" platformBuildVersionCode="33" platformBuildVersionName="13">
    <uses-sdk android:minSdkVersion="28" android:targetSdkVersion="33"/>
    <permission android:name="com.ad2001.frida0x4.DYNAMIC_RECEIVER_NOT_EXPORTED_PERMISSION" android:protectionLevel="signature"/>
    <uses-permission android:name="com.ad2001.frida0x4.DYNAMIC_RECEIVER_NOT_EXPORTED_PERMISSION"/>
    <application android:theme="@style/Theme.Frida0x4" android:label="@string/app_name" android:icon="@mipmap/ic_launcher" android:debuggable="true" android:allowBackup="true" android:supportsRtl="true" android:extractNativeLibs="false" android:fullBackupContent="@xml/backup_rules" android:roundIcon="@mipmap/ic_launcher_round" android:appComponentFactory="androidx.core.app.CoreComponentFactory" android:dataExtractionRules="@xml/data_extraction_rules">
        <activity android:name="com.ad2001.frida0x4.MainActivity" android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/>
                <category android:name="android.intent.category.LAUNCHER"/>
            </intent-filter>
        </activity>
        <provider android:name="androidx.startup.InitializationProvider" android:exported="false" android:authorities="com.ad2001.frida0x4.androidx-startup">
            <meta-data android:name="androidx.emoji2.text.EmojiCompatInitializer" android:value="androidx.startup"/>
            <meta-data android:name="androidx.lifecycle.ProcessLifecycleInitializer" android:value="androidx.startup"/>
        </provider>
    </application>
</manifest>
```

## Java analysis
Decompiling the APK reveals the `Check` class containing a non-static instance method `get_flag()`. Unlike the previous challenges where we dealt with static methods, this method requires an object instance to be called. The method performs the following operations:
1. Checks if the input parameter equals `1337`;
2. If correct, decodes an XOR-obfuscated string by XORing each byte with 15;
3. Returns the decoded flag string;

The obfuscated string `I]FKNtW@]JKPFA\[NALJr` is decoded byte-by-byte using XOR operation with key 15. 

The challenge is that this `get_flag()` method is never called in the normal application flow, and since it's an instance method, we need to create an instance of the `Check` class before we can invoke it.

```java
package com.ad2001.frida0x4;

/* loaded from: classes3.dex */
public class Check {
    public String get_flag(int a) {
        if (a == 1337) {
            byte[] decoded = new byte["I]FKNtW@]JKPFA\\[NALJr".getBytes().length];
            for (int i = 0; i < "I]FKNtW@]JKPFA\\[NALJr".getBytes().length; i++) {
                decoded[i] = (byte) ("I]FKNtW@]JKPFA\\[NALJr".getBytes()[i] ^ 15);
            }
            return new String(decoded);
        }
        return "";
    }
}
```

The Frida script demonstrates how to work with instance methods. First, it uses `Java.use()` to get a reference to the `Check` class. Then, it creates a new instance using the `$new()` method (Frida's way of calling a Java constructor). Once we have an instance, we can call the `get_flag()` method on it with the magic number `1337`, which returns the XOR-decoded flag string.

```js
function callGetFlag() {
    var Check = Java.use("com.ad2001.frida0x4.Check");

    var instance = Check.$new();

    var flag = instance.get_flag(1337);

    console.log("[*] flag is ", flag);
}

Java.perform(function () {
    callGetFlag();
});
```

Running the script successfully instantiates the `Check` class and calls the `get_flag()` method with parameter `1337`. The XOR decoding operation is performed, converting the obfuscated string into the readable flag.

```shell
$ frida -U -l script.js -f com.ad2001.frida0x4
     ____
    / _  |   Frida 16.7.13 - A world-class dynamic instrumentation toolkit
   | (_| |
    > _  |   Commands:
   /_/ |_|       help      -> Displays the help system
   . . . .       object?   -> Display information about 'object'
   . . . .       exit/quit -> Exit
   . . . .
   . . . .   More info at https://frida.re/docs/home/
   . . . .
   . . . .   Connected to Pixel 4a (id=)
Spawned `com.ad2001.frida0x4`. Resuming main thread!                    
[Pixel 4a::com.ad2001.frida0x4 ]-> [*] flag is  FRIDA{XORED_INSTANCE}

```

## Flag
FRIDA{XORED_INSTANCE}

## Static vs Instance methods
This challenge highlights a key difference between static and instance methods in Java, which affects how we use Frida:
- Static methods belong to the class itself, not to any particular object instance. They can be called directly on the class without creating an instance.
    ```js
    var MainActivity = Java.use("com.ad2001.frida0x2.MainActivity");
    MainActivity.get_flag(4919); // Call directly on the class
    ```

- Instance methods belong to individual objects created from a class. They require an object instance to be invoked and can access both instance and static members.
    ```js
    var Check = Java.use("com.ad2001.frida0x4.Check");
    var instance = Check.$new(); // Create instance first
    instance.get_flag(1337); // Call on the instance
    ```