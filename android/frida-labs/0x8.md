## Overview
This writeup details the reverse engineering of an Android application that validates user input against a hidden password in native code. The goal is to use Frida to hook the `strcmp` function and intercept the comparison arguments to reveal the flag without needing to reverse engineer the decryption algorithm.

## Initial analysis
First, the `AndroidManifest.xml` is examined to understand the app structure. Analysis reveals a single `MainActivity`.

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android" android:versionCode="1" android:versionName="1.0" android:compileSdkVersion="33" android:compileSdkVersionCodename="13" package="com.ad2001.frida0x8" platformBuildVersionCode="33" platformBuildVersionName="13">
    <uses-sdk android:minSdkVersion="28" android:targetSdkVersion="33"/>
    <permission android:name="com.ad2001.frida0x8.DYNAMIC_RECEIVER_NOT_EXPORTED_PERMISSION" android:protectionLevel="signature"/>
    <uses-permission android:name="com.ad2001.frida0x8.DYNAMIC_RECEIVER_NOT_EXPORTED_PERMISSION"/>
    <application android:theme="@style/Theme.Frida0x8" android:label="@string/app_name" android:icon="@mipmap/ic_launcher" android:debuggable="true" android:allowBackup="true" android:supportsRtl="true" android:extractNativeLibs="false" android:fullBackupContent="@xml/backup_rules" android:roundIcon="@mipmap/ic_launcher_round" android:appComponentFactory="androidx.core.app.CoreComponentFactory" android:dataExtractionRules="@xml/data_extraction_rules">
        <activity android:name="com.ad2001.frida0x8.MainActivity" android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/>
                <category android:name="android.intent.category.LAUNCHER"/>
            </intent-filter>
        </activity>
        <provider android:name="androidx.startup.InitializationProvider" android:exported="false" android:authorities="com.ad2001.frida0x8.androidx-startup">
            <meta-data android:name="androidx.emoji2.text.EmojiCompatInitializer" android:value="androidx.startup"/>
            <meta-data android:name="androidx.lifecycle.ProcessLifecycleInitializer" android:value="androidx.startup"/>
        </provider>
    </application>
</manifest>
```

## Java analysis
Next, the APK is decompiled with `jadx-gui` to examine `MainActivity.java`. The `MainActivity` loads a native library called `frida0x8` and declares a JNI method `cmpstr(String str)`. The native library is loaded using `System.loadLibrary("frida0x8")` in the static initializer.

```java
package com.ad2001.frida0x8;

import android.os.Bundle;
import android.view.View;
import android.widget.Button;
import android.widget.EditText;
import android.widget.Toast;
import androidx.appcompat.app.AppCompatActivity;
import com.ad2001.frida0x8.databinding.ActivityMainBinding;

/* loaded from: classes4.dex */
public class MainActivity extends AppCompatActivity {
    private ActivityMainBinding binding;
    Button btn;
    EditText edt;

    public native int cmpstr(String str);

    static {
        System.loadLibrary("frida0x8");
    }

    /* JADX INFO: Access modifiers changed from: protected */
    @Override // androidx.fragment.app.FragmentActivity, androidx.activity.ComponentActivity, androidx.core.app.ComponentActivity, android.app.Activity
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        ActivityMainBinding inflate = ActivityMainBinding.inflate(getLayoutInflater());
        this.binding = inflate;
        setContentView(inflate.getRoot());
        this.edt = (EditText) findViewById(C0571R.C0574id.editTextText);
        Button button = (Button) findViewById(C0571R.C0574id.button);
        this.btn = button;
        button.setOnClickListener(new View.OnClickListener() { // from class: com.ad2001.frida0x8.MainActivity.1
            @Override // android.view.View.OnClickListener
            public void onClick(View v) {
                String ip = MainActivity.this.edt.getText().toString();
                int res = MainActivity.this.cmpstr(ip);
                if (res == 1) {
                    Toast.makeText(MainActivity.this, "YEY YOU GOT THE FLAG " + ip, 1).show();
                } else {
                    Toast.makeText(MainActivity.this, "TRY AGAIN", 1).show();
                }
            }
        });
    }
}
```

## Native library analysis
`Ghidra` is used to disassemble and decompile the `libfrida0x8.so` library. The JNI function `Java_com_ad2001_frida0x8_MainActivity_cmpstr` implements the password validation logic. This is the raw decompiled output from Ghidra, followed by a cleaned-up version with better variable names.

```c
bool Java_com_ad2001_frida0x8_MainActivity_cmpstr
               (_JNIEnv *param_1,undefined8 param_2,_jstring *param_3)

{
  int iVar1;
  char *__s1;
  ulong uVar2;
  long lVar3;
  int local_cc;
  char acStack_7c [100];
  long local_18;
  
  lVar3 = tpidr_el0;
  local_18 = *(long *)(lVar3 + 0x28);
  __s1 = (char *)_JNIEnv::GetStringUTFChars(param_1,param_3,(uchar *)0x0);
  local_cc = 0;
  while( true ) {
    uVar2 = __strlen_chk("GSJEB|OBUJWF`MBOE~",0xffffffffffffffff);
    if (uVar2 <= (ulong)(long)local_cc) break;
    acStack_7c[local_cc] = "GSJEB|OBUJWF`MBOE~"[local_cc] + -1;
    local_cc = local_cc + 1;
  }
  lVar3 = __strlen_chk("GSJEB|OBUJWF`MBOE~",0xffffffffffffffff);
  acStack_7c[lVar3] = '\0';
  iVar1 = strcmp(__s1,acStack_7c);
  __android_log_print(3,"input ",&DAT_00100678,__s1);
  __android_log_print(3,"Password",&DAT_00100678,acStack_7c);
  _JNIEnv::ReleaseStringUTFChars(param_1,param_3,__s1);
  lVar3 = tpidr_el0;
  if (*(long *)(lVar3 + 0x28) == local_18) {
    return iVar1 == 0;
  }
                    /* WARNING: Subroutine does not return */
  __stack_chk_fail();
}
```

The decryption loop iterates through each character of the obfuscated string and applies the transformation `flag[idx] = encrypted[idx] - 1`. The key insight is that rather than manually decoding this string, we can hook the `strcmp()` function at runtime to intercept both the user input and the flag arguments.

Here's the same code with improved variable names for clarity:

```c

bool Java_com_ad2001_frida0x8_MainActivity_cmpstr
               (_JNIEnv *param_1,undefined8 param_2,_jstring *param_3)

{
  int cmp_result;
  char *user_input;
  ulong uVar2;
  long lVar3;
  // prepare a buffer for the decoded flag
  int idx;
  char flag [100];
  long local_18;
  
  lVar3 = tpidr_el0;
  local_18 = *(long *)(lVar3 + 0x28);

  // retrieves user input string (ip)
  user_input = (char *)_JNIEnv::GetStringUTFChars(param_1,param_3,(uchar *)0x0);
  idx = 0;

  // decode the flag replacing each char with (char-1) (e.g. G -> F, etc)
  while( true ) {
    uVar2 = __strlen_chk("GSJEB|OBUJWF`MBOE~",0xffffffffffffffff);
    if (uVar2 <= (ulong)(long)idx) break;
    flag[idx] = "GSJEB|OBUJWF`MBOE~"[idx] + -1;
    idx = idx + 1;
  }
  lVar3 = __strlen_chk("GSJEB|OBUJWF`MBOE~",0xffffffffffffffff);
  flag[lVar3] = '\0';

  // calls libc 'strcmp'
  cmp_result = strcmp(user_input,flag);
  __android_log_print(3,"input ",&DAT_00100678,user_input);
  __android_log_print(3,"Password",&DAT_00100678,flag);
  _JNIEnv::ReleaseStringUTFChars(param_1,param_3,user_input);
  
  // stack canary protection
  lVar3 = tpidr_el0;
  if (*(long *)(lVar3 + 0x28) == local_18) {
    return cmp_result == 0;
  }
                    /* WARNING: Subroutine does not return */
  __stack_chk_fail();
}
```


This script demonstrates how to hook the `strcmp` function from `libc` to intercept the password comparison. The `setTimeout()` delays execution by 1 second to ensure the app is fully loaded. `Module.findExportByName()` locates the `strcmp` symbol in the system's C library (`libc.so`).

The conditional check if `(str1 == "test")` filters the output to only display comparisons where the user entered `test`, reducing noise from other unrelated `strcmp` calls throughout the system.

```js
setTimeout(function () {
    var addr = Module.findExportByName("libc.so", "strcmp");
    console.log("[*] strcmp address:", addr);

    Interceptor.attach(addr, {
        onEnter: function (args) {
            // args[0] is the first string (user_input)
            // args[1] is the second string (flag)
            var str1 = Memory.readUtf8String(args[0]);
            var str2 = Memory.readUtf8String(args[1]);
            
            // "test" is inserted in the input box of the application
            if (str1 == "test") {
                console.log("[*] strcmp called:");
                console.log("[*] arg1 (user input):", str1);
                console.log("[*] arg2 (flag):", str2);
            }
        }
    });
}, 1000);
```

The output confirms that the function was located at `0xe4457df0` and that the hook successfully intercepted the `onEnter` callback of `strcmp()`, printing its arguments.
```shell
$ frida -U -f com.ad2001.frida0x8 -l script.js
     ____
    / _  |   Frida 16.7.13 - A world-class dynamic instrumentation toolkit
   | (_| |
    > _  |   Commands:
   /_/ |_|       help      -> Displays the help system
   . . . .       object?   -> Display information about 'object'
   . . . .       exit/quit -> Exit
   . . . .
   . . . .   More info at https://frida.re/docs/home/
   . . . .
   . . . .   Connected to Nexus 4 (id=)
Spawned `com.ad2001.frida0x8`. Resuming main thread!                    
[Nexus 4::com.ad2001.frida0x8 ]-> [*] strcmp address: 0xe4457df0
[*] strcmp called:
[*] arg1 (user input): test
[*] arg2 (flag): FRIDA{NATIVE_LAND}
```

## Flag
FRIDA{NATIVE_LAND}