## Overview
This writeup details the reverse engineering of an Android application that requires hooking a method and replacing its parameter with a custom object. The goal is to intercept the `flag()` method call and substitute the incorrect `Checker` instance with one that has valid values to decrypt and reveal the flag.

## Initial analysis
The `AndroidManifest.xml` shows a simple application structure with the main activity `com.ad2001.frida0x7.MainActivity` as the entry point.

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android" android:versionCode="1" android:versionName="1.0" android:compileSdkVersion="33" android:compileSdkVersionCodename="13" package="com.ad2001.frida0x7" platformBuildVersionCode="33" platformBuildVersionName="13">
    <uses-sdk android:minSdkVersion="28" android:targetSdkVersion="33"/>
    <permission android:name="com.ad2001.frida0x7.DYNAMIC_RECEIVER_NOT_EXPORTED_PERMISSION" android:protectionLevel="signature"/>
    <uses-permission android:name="com.ad2001.frida0x7.DYNAMIC_RECEIVER_NOT_EXPORTED_PERMISSION"/>
    <application android:theme="@style/Theme.Frida0x7" android:label="@string/app_name" android:icon="@mipmap/ic_launcher" android:debuggable="true" android:allowBackup="true" android:supportsRtl="true" android:extractNativeLibs="false" android:fullBackupContent="@xml/backup_rules" android:roundIcon="@mipmap/ic_launcher_round" android:appComponentFactory="androidx.core.app.CoreComponentFactory" android:dataExtractionRules="@xml/data_extraction_rules">
        <activity android:name="com.ad2001.frida0x7.MainActivity" android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/>
                <category android:name="android.intent.category.LAUNCHER"/>
            </intent-filter>
        </activity>
        <provider android:name="androidx.startup.InitializationProvider" android:exported="false" android:authorities="com.ad2001.frida0x7.androidx-startup">
            <meta-data android:name="androidx.emoji2.text.EmojiCompatInitializer" android:value="androidx.startup"/>
            <meta-data android:name="androidx.lifecycle.ProcessLifecycleInitializer" android:value="androidx.startup"/>
        </provider>
    </application>
</manifest>
```

## Java analysis
Decompiling the APK with `jadx-gui` reveals the `MainActivity` class that creates a `Checker` instance with incorrect values `(123, 321)` and calls the `flag()` method. The `flag()` method checks if both `num1` and `num2` are greater than `512`. 

Since the values passed are too small, the flag is never decrypted during normal execution. The challenge is to hook the `flag()` method and replace the parameter with a `Checker` instance containing valid values (both greater than `512`).

```java
package com.ad2001.frida0x7;

import android.os.Bundle;
import android.widget.TextView;
import androidx.appcompat.app.AppCompatActivity;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.util.Base64;
import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.SecretKeySpec;

/* loaded from: classes3.dex */
public class MainActivity extends AppCompatActivity {

    /* renamed from: t1 */
    TextView f103t1;

    /* JADX INFO: Access modifiers changed from: protected */
    @Override // androidx.fragment.app.FragmentActivity, androidx.activity.ComponentActivity, androidx.core.app.ComponentActivity, android.app.Activity
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(C0569R.layout.activity_main);
        this.f103t1 = (TextView) findViewById(C0569R.C0572id.textview);
        Checker ch = new Checker(123, 321);
        try {
            flag(ch);
        } catch (InvalidKeyException e) {
            throw new RuntimeException(e);
        } catch (NoSuchAlgorithmException e2) {
            throw new RuntimeException(e2);
        } catch (BadPaddingException e3) {
            throw new RuntimeException(e3);
        } catch (IllegalBlockSizeException e4) {
            throw new RuntimeException(e4);
        } catch (NoSuchPaddingException e5) {
            throw new RuntimeException(e5);
        }
    }

    public void flag(Checker A) throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException {
        if (A.num1 > 512 && 512 < A.num2) {
            Cipher cipher = Cipher.getInstance("AES");
            SecretKeySpec secretKeySpec = new SecretKeySpec("MySecureKey12345".getBytes(), "AES");
            cipher.init(2, secretKeySpec);
            byte[] decryptedBytes = Base64.getDecoder().decode("cL/bBqDmfO0IXXJCVFwYLeHp1k3mQr+SP6rlQGUPZTY=");
            String decrypted = new String(cipher.doFinal(decryptedBytes));
            this.f103t1.setText(decrypted);
        }
    }
}
```

File: Checker.java
```java
package com.ad2001.frida0x7;

/* loaded from: classes3.dex */
public class Checker {
    int num1;
    int num2;

    /* JADX INFO: Access modifiers changed from: package-private */
    public Checker(int a, int b) {
        this.num1 = a;
        this.num2 = b;
    }
}
```

The solution hooks the `flag()` method and replaces its implementation. When the method is called, we create a new `Checker` instance with valid values `(513, 513)` that satisfy the condition `num1 > 512 && num2 > 512`. We then call the original `flag()` method with our substituted instance, bypassing the incorrect values passed by the application and triggering the AES decryption.

```js
function callFlag() {
    var Checker = Java.use("com.ad2001.frida0x7.Checker");
    var instance = Checker.$new(513, 513);

    var MainActivity = Java.use("com.ad2001.frida0x7.MainActivity");

    MainActivity.flag.implementation = function () {
        console.log("called flag");
        this.flag(instance);
    };
}

Java.perform(function () {
    callFlag();
});
```

Running the Frida script successfully hooks the `flag()` method. When the application calls `flag()` with the incorrect `Checker` instance, our hook intercepts it and calls the method with our valid instance `(513, 513)`, triggering the AES decryption and displaying the flag on screen.

```shell
$ frida -U -l script.js -f com.ad2001.frida0x7
     ____
    / _  |   Frida 16.7.13 - A world-class dynamic instrumentation toolkit
   | (_| |
    > _  |   Commands:
   /_/ |_|       help      -> Displays the help system
   . . . .       object?   -> Display information about 'object'
   . . . .       exit/quit -> Exit
   . . . .
   . . . .   More info at https://frida.re/docs/home/
   . . . .
   . . . .   Connected to Pixel 4a (id=)
Spawned `com.ad2001.frida0x7`. Resuming main thread!                    
[Pixel 4a::com.ad2001.frida0x7 ]-> called flag
```

## Flag
FRIDA{HOOKING_CONSTRUCTORS}